<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–¢—Ä–µ—Ç–∏–π –ø–µ—Ö–æ—Ç–Ω—ã–π –ø–æ–ª–∫</title>
  <style>
    body {
      font-family: "Trebuchet MS", sans-serif;
      background: #0e0d16;
      color: #f5f2d0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
    }
    .game-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      padding: 12px;
      box-sizing: border-box;
    }
    .info-column {
      width: 250px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    h1 { 
      margin: 0 0 10px 0; 
      text-align: left;
      font-size: 24px;
    }
    #level {
      font-size: 18px;
      margin: 0;
      text-align: left;
      color: #dfbf6c;
    }
    #lives {
      font-size: 20px;
      margin: 0;
      text-align: left;
    }
    #game-wrapper {
      width: 100%;
      height: 100%;
      padding: 12px;
      border: 3px solid #6f5b3e;
      border-radius: 12px;
      background: #1f1b2f;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
    }
    canvas {
      background: #100c1b;
      border: 2px solid #b9a06b;
      border-radius: 8px;
      image-rendering: pixelated;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    button {
      margin: 0;
      padding: 10px 24px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background: #dfbf6c;
      color: #2b1f0f;
      font-weight: bold;
      width: 100%;
    }
    button:hover { background: #f9d885; }
    #game-over {
      font-size: 20px;
      color: #ffb3b3;
      min-height: 24px;
      margin: 0;
      text-align: left;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="game-column">
      <div id="game-wrapper">
        <canvas id="game" width="1440" height="900"></canvas>
      </div>
    </div>
    <div class="info-column">
      <h1>–¢—Ä–µ—Ç–∏–π –ø–µ—Ö–æ—Ç–Ω—ã–π –ø–æ–ª–∫</h1>
      <div id="level">–£—Ä–æ–≤–µ–Ω—å: 1 | –£–±–∏—Ç–æ: 0/10</div>
      <div id="lives">–ñ–∏–∑–Ω–∏: ‚ô•‚ô•‚ô•</div>
      <div id="game-over"></div>
      <button id="start-btn">–°—Ç–∞—Ä—Ç</button>
      <button id="pause-btn" style="display: none;">–ü–∞—É–∑–∞</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const livesDisplay = document.getElementById('lives');
    const levelDisplay = document.getElementById('level');
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const gameOverText = document.getElementById('game-over');
    const gameWrapper = document.getElementById('game-wrapper');

    // –ë–∞–∑–æ–≤—ã–µ —Ä–∞–∑–º–µ—Ä—ã (–ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ 16:10, —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞ 24x15 –∫–ª–µ—Ç–æ–∫, –∫–ª–µ—Ç–∫–∏ —É–≤–µ–ª–∏—á–µ–Ω—ã –≤ 1.5 —Ä–∞–∑–∞)
    const BASE_WIDTH = 1440;  // 24 –∫–ª–µ—Ç–∫–∏ * 60
    const BASE_HEIGHT = 900;  // 15 –∫–ª–µ—Ç–æ–∫ * 60
    const ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT; // 1.6

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ canvas
    function resizeCanvas() {
      // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–∞–∑–º–µ—Ä canvas –≤—Å–µ–≥–¥–∞ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–ª—è –ª–æ–≥–∏–∫–∏ –∏–≥—Ä—ã
      canvas.width = BASE_WIDTH;  // 1440
      canvas.height = BASE_HEIGHT; // 900
      
      // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã game-wrapper (–º–∏–Ω—É—Å padding –∏ border)
      const wrapperRect = gameWrapper.getBoundingClientRect();
      const availableWidth = wrapperRect.width - 24; // padding + border
      const availableHeight = wrapperRect.height - 24; // padding + border
      
      // –í—ã—á–∏—Å–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–π
      // –ö–∞—Ä—Ç–∞ –¥–æ–ª–∂–Ω–∞ –∑–∞–Ω–∏–º–∞—Ç—å –≤—Å—é –¥–æ—Å—Ç—É–ø–Ω—É—é –≤—ã—Å–æ—Ç—É
      let displayHeight = availableHeight;
      let displayWidth = displayHeight * ASPECT_RATIO;
      
      // –ï—Å–ª–∏ —à–∏—Ä–∏–Ω–∞ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è, —É–º–µ–Ω—å—à–∞–µ–º –ø–æ —à–∏—Ä–∏–Ω–µ
      if (displayWidth > availableWidth) {
        displayWidth = availableWidth;
        displayHeight = displayWidth / ASPECT_RATIO;
      }
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —á–µ—Ä–µ–∑ CSS (–º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ)
      canvas.style.width = Math.floor(displayWidth) + 'px';
      canvas.style.height = Math.floor(displayHeight) + 'px';
    }

    // –í—ã–∑—ã–≤–∞–µ–º –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const tileSize = 60;  // –£–≤–µ–ª–∏—á–µ–Ω–æ –≤ 1.5 —Ä–∞–∑–∞ (–±—ã–ª–æ 40)
    const halfTile = tileSize / 2;

    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      targetX: canvas.width / 2,
      targetY: canvas.height / 2,
      tileX: 0,
      tileY: 0,
      size: tileSize,
      speed: 6,
      dirX: 1,
      dirY: 0
    };

    let arrows = [];
    let enemies = [];
    let keys = {};
    let score = 0;
    let lives = 3;
    let playing = false;
    let paused = false;
    let spawnTimer = 0;
    let animationId = null;
    let currentLevel = 1;
    let killsInLevel = 0;
    const KILLS_NEEDED_PER_LEVEL = 10;
    const MAX_LEVEL = 30;
    let playerDeathAnimation = null; // –ê–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    let levelTransitionActive = false; // –§–ª–∞–≥ –ø–µ—Ä–µ—Ö–æ–¥–∞ –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏
    
    // –û–ø–∏—Å–∞–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ä—Ç—ã
    const mapApproaches = [
      '–ö—Ä–µ—Å—Ç 1', '–î–∏–∞–≥–æ–Ω–∞–ª—å 1', '–ö–æ–ª—å—Ü–∞ 1', '–ó–∏–≥–∑–∞–≥ 1', '–ü–∏—Ä–∞–º–∏–¥–∞ 1', '–í–æ–ª–Ω—ã 1',
      '–ö—Ä–µ—Å—Ç 2', '–î–∏–∞–≥–æ–Ω–∞–ª—å 2', '–ö–æ–ª—å—Ü–∞ 2', '–ó–∏–≥–∑–∞–≥ 2', '–ü–∏—Ä–∞–º–∏–¥–∞ 2', '–í–æ–ª–Ω—ã 2',
      '–ö—Ä–µ—Å—Ç 3', '–î–∏–∞–≥–æ–Ω–∞–ª—å 3', '–ö–æ–ª—å—Ü–∞ 3', '–ó–∏–≥–∑–∞–≥ 3', '–ü–∏—Ä–∞–º–∏–¥–∞ 3', '–í–æ–ª–Ω—ã 3',
      '–ö—Ä–µ—Å—Ç 4', '–î–∏–∞–≥–æ–Ω–∞–ª—å 4', '–ö–æ–ª—å—Ü–∞ 4', '–ó–∏–≥–∑–∞–≥ 4', '–ü–∏—Ä–∞–º–∏–¥–∞ 4', '–í–æ–ª–Ω—ã 4',
      '–ö—Ä–µ—Å—Ç 5', '–î–∏–∞–≥–æ–Ω–∞–ª—å 5', '–ö–æ–ª—å—Ü–∞ 5', '–ó–∏–≥–∑–∞–≥ 5', '–ü–∏—Ä–∞–º–∏–¥–∞ 5', '–í–æ–ª–Ω—ã 5'
    ];

    function resetGame() {
      currentLevel = 1;
      killsInLevel = 0;
      paused = false;
      updateMapForLevel(1);
      const approxTx = Math.floor(mapRows[0].length / 2);
      const approxTy = Math.floor(mapRows.length / 2);
      const centerTile = findNearestWalkableTile(approxTx, approxTy);
      setEntityToTile(player, centerTile.tx, centerTile.ty);
      player.dirX = 1;
      player.dirY = 0;
      arrows = [];
      enemies = [];
      score = 0;
      lives = 3;
      spawnTimer = 0;
      playerDeathAnimation = null;
      levelTransitionActive = false;
      pauseBtn.textContent = '–ü–∞—É–∑–∞';
      pauseBtn.style.display = 'none';
      startBtn.style.display = 'block';
      updateLives();
      updateLevelDisplay();
      gameOverText.textContent = '';
    }

    function updateLevelDisplay() {
      const approach = mapApproaches[currentLevel - 1] || '';
      levelDisplay.textContent = `–£—Ä–æ–≤–µ–Ω—å: ${currentLevel} | –£–±–∏—Ç–æ: ${killsInLevel}/${KILLS_NEEDED_PER_LEVEL}`;
      if (approach) {
        levelDisplay.textContent += ` | ${approach}`;
      }
      // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É –æ –≤–∏–∑—É–∞–ª—å–Ω–æ–º —Ä–∞–∑–ª–∏—á–∏–∏
      levelDisplay.title = approach || '';
    }

    function nextLevel() {
      if (currentLevel >= MAX_LEVEL) {
        playing = false;
        paused = false;
        pauseBtn.style.display = 'none';
        startBtn.style.display = 'block';
        enemies = [];
        arrows = [];
        playVictoryMusic();
        gameOverText.textContent = 'üéâ –ü–æ–±–µ–¥–∞! –í—Å–µ 30 —É—Ä–æ–≤–Ω–µ–π –ø—Ä–æ–π–¥–µ–Ω—ã!';
        return;
      }
      playVictoryMusic();
      levelTransitionActive = true;
      
      // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∂–∏–∑–Ω–∏ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å
      lives = 3;
      updateLives();
      
      // –ê–Ω–∏–º–∞—Ü–∏—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏
      setTimeout(() => {
        levelTransitionActive = false;
        currentLevel++;
        killsInLevel = 0;
        enemies = [];
        arrows = [];
        playerDeathAnimation = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Å–º–µ—Ä—Ç–∏
        updateMapForLevel(currentLevel);
        const approxTx = Math.floor(mapRows[0].length / 2);
        const approxTy = Math.floor(mapRows.length / 2);
        const centerTile = findNearestWalkableTile(approxTx, approxTy);
        setEntityToTile(player, centerTile.tx, centerTile.ty);
        player.dirX = 1;
        player.dirY = 0;
        updateLevelDisplay();
        gameOverText.textContent = `–£—Ä–æ–≤–µ–Ω—å ${currentLevel}! –£–±–µ–π ${KILLS_NEEDED_PER_LEVEL} –≤—Ä–∞–≥–æ–≤. –ñ–∏–∑–Ω–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!`;
        setTimeout(() => {
          gameOverText.textContent = '';
        }, 3000);
      }, 2000); // –ó–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∑–≤—É–∫–æ–≤–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
    }

    const levelMaps = [
      // –£—Ä–æ–≤–µ–Ω—å 1 - –ö—Ä–µ—Å—Ç (–ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–µ—Å—è –∫–æ—Ä–∏–¥–æ—Ä—ã)
      [
        '011111111111111111111110',
        '000000000000000000000000',
        '011111111110111111111110',  // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
        '000000000000000000000000',
        '011111111110111111111110',
        '000000000000000000000000',
        '000000000000000000000000',  // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –∫–æ—Ä–∏–¥–æ—Ä
        '000000000000000000000000',
        '000000000000000000000000',
        '000000000000000000000000',
        '011111111110111111111110',
        '000000000000000000000000',
        '011111111110111111111110',
        '000000000000000000000000',
        '011111111111111111111110'
      ],
      // –£—Ä–æ–≤–µ–Ω—å 2 - –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –ª–∞–±–∏—Ä–∏–Ω—Ç (–ª–µ—Å—Ç–Ω–∏—Ü–∞)
      [
        '011111111111111111111110',
        '000000000000000000000000',
        '001111000000000000000000',  // –°—Ç–µ–Ω–∞ —Å–ª–µ–≤–∞ –≤–≤–µ—Ä—Ö—É
        '000000000000000000000000',
        '000000011110000000000000',
        '000000000000000000000000',
        '000000000000111100000000',  // –î–∏–∞–≥–æ–Ω–∞–ª—å
        '000000000000000000000000',
        '000000000000000011110000',  // –°—Ç–µ–Ω–∞ —Å–ø—Ä–∞–≤–∞ –≤–Ω–∏–∑—É
        '000000000000000000000000',
        '000011110000000000000000',
        '000000000000000000000000',
        '000000000111100000000000',
        '000000000000000000000000',
        '011111111111111111111110'
      ],
      // –£—Ä–æ–≤–µ–Ω—å 3 - –ö–æ–Ω—Ü–µ–Ω—Ç—Ä–∏—á–µ—Å–∫–∏–µ –∫–æ–ª—å—Ü–∞
      [
        '011111111111111111111110',
        '000000000000000000000000',
        '001111111111111111111110',  // –í–Ω–µ—à–Ω–µ–µ –∫–æ–ª—å—Ü–æ
        '000000000000000000000000',
        '001110000000000000011110',
        '000000000000000000000000',
        '001110000001111000011110',  // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∫–æ–ª—å—Ü–æ
        '000000000000000000000000',
        '001110000000000000011110',
        '000000000000000000000000',
        '001111111111111111111110',
        '000000000000000000000000',
        '000000000000000000000000',
        '000000000000000000000000',
        '011111111111111111111110'
      ],
      // –£—Ä–æ–≤–µ–Ω—å 4 - –ó–∏–≥–∑–∞–≥ (–º–æ–ª–Ω–∏—è)
      [
        '011111111111111111111110',
        '000000000000000000000000',
        '000000111111111111111110',  // –ó–∏–≥–∑–∞–≥ –≤–ø—Ä–∞–≤–æ
        '000000000000000000000000',
        '000000000111111111111110',
        '000000000000000000000000',
        '001111000000000000000000',  // –ó–∏–≥–∑–∞–≥ –≤–ª–µ–≤–æ
        '000000000000000000000000',
        '000000011110000000000000',
        '000000000000000000000000',
        '000000000000111111111110',  // –ó–∏–≥–∑–∞–≥ –≤–ø—Ä–∞–≤–æ
        '000000000000000000000000',
        '000000000000000011111110',
        '000000000000000000000000',
        '011111111111111111111110'
      ],
      // –£—Ä–æ–≤–µ–Ω—å 5 - –ü–∏—Ä–∞–º–∏–¥–∞ (—Å—Ç—É–ø–µ–Ω–∏)
      [
        '011111111111111111111110',
        '000000000000000000000000',
        '000000000000000000000000',
        '000000000000000000000000',
        '000011111111111111110000',  // –û—Å–Ω–æ–≤–∞–Ω–∏–µ –ø–∏—Ä–∞–º–∏–¥—ã
        '000000000000000000000000',
        '000000011111111111000000',
        '000000000000000000000000',
        '000000000011111110000000',  // –°–µ—Ä–µ–¥–∏–Ω–∞
        '000000000000000000000000',
        '000000000000111100000000',  // –í–µ—Ä—à–∏–Ω–∞
        '000000000000000000000000',
        '000000000000000000000000',
        '000000000000000000000000',
        '011111111111111111111110'
      ],
      // –£—Ä–æ–≤–µ–Ω—å 6 - –í–æ–ª–Ω—ã (—Å–∏–Ω—É—Å–æ–∏–¥–∞)
      [
        '011111111111111111111110',
        '000000000000000000000000',
        '000011110000000000111110',  // –í–æ–ª–Ω–∞ –≤–≤–µ—Ä—Ö
        '000000000000000000000000',
        '001111111100011111111110',
        '000000000000000000000000',
        '011111111111111111111110',  // –í–æ–ª–Ω–∞ –ø–æ–ª–Ω–∞—è (–º–∞–∫—Å–∏–º—É–º)
        '000000000000000000000000',
        '011111111111111111111110',
        '000000000000000000000000',
        '001111111100011111111110',
        '000000000000000000000000',
        '000011110000000000111110',  // –í–æ–ª–Ω–∞ –≤–Ω–∏–∑
        '000000000000000000000000',
        '011111111111111111111110'
      ]
    ];

    let mapRows = levelMaps[0];
    let leftSpawnTiles = [];
    let portals = [];

    function updateMapForLevel(level) {
      // –ü–æ–≤—Ç–æ—Ä—è–µ–º –∫–∞—Ä—Ç—ã —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏: –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–¥—É–ª—å –æ—Ç –¥–ª–∏–Ω—ã –±–∞–∑–æ–≤—ã—Ö –∫–∞—Ä—Ç
      const mapIndex = (level - 1) % 6;
      mapRows = levelMaps[mapIndex];
      leftSpawnTiles = [];
      for (let ty = 0; ty < mapRows.length; ty++) {
        for (let tx = 0; tx < mapRows[ty].length; tx++) {
          if (mapRows[ty].charAt(tx) === '0' && tx <= 2) {
            leftSpawnTiles.push({ tx, ty });
          }
        }
      }
      
      // –°–æ–∑–¥–∞—ë–º 3 –º–∞–≥–∏—á–µ—Å–∫–∏—Ö –ø–æ—Ä—Ç–∞–ª–∞: 2 —Å–ª–µ–≤–∞, 1 —Å–ø—Ä–∞–≤–∞
      portals = [];
      const maxX = mapRows[0].length - 1;
      
      // –ù–∞—Ö–æ–¥–∏–º –ø—Ä–æ—Ö–æ–¥–∏–º—ã–µ —Ç–∞–π–ª—ã –Ω–∞ –ª–µ–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ (tx = 0)
      const walkableLeftTiles = [];
      for (let ty = 0; ty < mapRows.length; ty++) {
        if (isWalkableTile(0, ty)) {
          walkableLeftTiles.push(ty);
        }
      }
      
      // –ù–∞—Ö–æ–¥–∏–º –ø—Ä–æ—Ö–æ–¥–∏–º—ã–µ —Ç–∞–π–ª—ã –Ω–∞ –ø—Ä–∞–≤–æ–π –≥—Ä–∞–Ω–∏—Ü–µ (tx = maxX)
      const walkableRightTiles = [];
      for (let ty = 0; ty < mapRows.length; ty++) {
        if (isWalkableTile(maxX, ty)) {
          walkableRightTiles.push(ty);
        }
      }
      
      // –°–æ–∑–¥–∞—ë–º 2 –ø–æ—Ä—Ç–∞–ª–∞ —Å–ª–µ–≤–∞
      if (walkableLeftTiles.length >= 2) {
        // –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º 2 –ø–æ—Ä—Ç–∞–ª–∞
        const step = Math.floor(walkableLeftTiles.length / 3);
        for (let i = 0; i < 2; i++) {
          const index = Math.min(i * step + step, walkableLeftTiles.length - 1);
          const ty = walkableLeftTiles[index];
          portals.push({
            tx: 0,
            ty: ty,
            x: 0 * tileSize + halfTile,
            y: ty * tileSize + halfTile,
            animationPhase: 0
          });
        }
      } else if (walkableLeftTiles.length === 1) {
        // –ï—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥–∏–º—ã–π —Ç–∞–π–ª, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –¥–≤–∞–∂–¥—ã
        const ty = walkableLeftTiles[0];
        portals.push({
          tx: 0,
          ty: ty,
          x: 0 * tileSize + halfTile,
          y: ty * tileSize + halfTile,
          animationPhase: 0
        });
        portals.push({
          tx: 0,
          ty: ty,
          x: 0 * tileSize + halfTile,
          y: ty * tileSize + halfTile,
          animationPhase: 0
        });
      } else {
        // –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä–æ—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–π–ª–æ–≤ —Å–ª–µ–≤–∞, –∏—â–µ–º –±–ª–∏–∂–∞–π—à–∏–µ
        for (let i = 0; i < 2; i++) {
          const targetY = Math.floor((mapRows.length / 3) * (i + 1));
          let found = false;
          for (let tx = 0; tx < 2 && !found; tx++) {
            for (let ty = 0; ty < mapRows.length; ty++) {
              if (isWalkableTile(tx, ty)) {
                portals.push({
                  tx: tx,
                  ty: ty,
                  x: tx * tileSize + halfTile,
                  y: ty * tileSize + halfTile,
                  animationPhase: 0
                });
                found = true;
                break;
              }
            }
          }
          if (!found) {
            const nearest = findNearestWalkableTile(0, targetY);
            portals.push({
              tx: nearest.tx,
              ty: nearest.ty,
              x: nearest.tx * tileSize + halfTile,
              y: nearest.ty * tileSize + halfTile,
              animationPhase: 0
            });
          }
        }
      }
      
      // –°–æ–∑–¥–∞—ë–º 1 –ø–æ—Ä—Ç–∞–ª —Å–ø—Ä–∞–≤–∞
      if (walkableRightTiles.length > 0) {
        const middleIndex = Math.floor(walkableRightTiles.length / 2);
        const ty = walkableRightTiles[middleIndex];
        portals.push({
          tx: maxX,
          ty: ty,
          x: maxX * tileSize + halfTile,
          y: ty * tileSize + halfTile,
          animationPhase: 0
        });
      } else {
        // –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä–æ—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–π–ª–æ–≤ —Å–ø—Ä–∞–≤–∞, –∏—â–µ–º –±–ª–∏–∂–∞–π—à–∏–π
        const targetY = Math.floor(mapRows.length / 2);
        let found = false;
        for (let tx = maxX; tx >= maxX - 1 && !found; tx--) {
          for (let ty = 0; ty < mapRows.length; ty++) {
            if (isWalkableTile(tx, ty)) {
              portals.push({
                tx: tx,
                ty: ty,
                x: tx * tileSize + halfTile,
                y: ty * tileSize + halfTile,
                animationPhase: 0
              });
              found = true;
              break;
            }
          }
        }
        if (!found) {
          const nearest = findNearestWalkableTile(maxX, targetY);
          portals.push({
            tx: nearest.tx,
            ty: nearest.ty,
            x: nearest.tx * tileSize + halfTile,
            y: nearest.ty * tileSize + halfTile,
            animationPhase: 0
          });
        }
      }
    }

    updateMapForLevel(1);

    function isWalkableTile(tx, ty) {
      return mapRows[ty]?.charAt(tx) === '0';
    }

    function tileCenter(tx, ty) {
      return {
        x: tx * tileSize + halfTile,
        y: ty * tileSize + halfTile
      };
    }

    function findNearestWalkableTile(tx, ty) {
      for (let radius = 0; radius < 4; radius++) {
        for (let dx = -radius; dx <= radius; dx++) {
          for (let dy = -radius; dy <= radius; dy++) {
            const nx = (tx + dx) * tileSize + tileSize / 2;
            const ny = (ty + dy) * tileSize + tileSize / 2;
            const tileX = Math.floor((nx - halfTile) / tileSize);
            const tileY = Math.floor((ny - halfTile) / tileSize);
            if (isWalkableTile(tileX, tileY)) {
              return { tx: tileX, ty: tileY };
            }
          }
        }
      }
      return { tx, ty };
    }

    function positionToTile(x, y) {
      const tx = Math.round((x - halfTile) / tileSize);
      const ty = Math.round((y - halfTile) / tileSize);
      return findNearestWalkableTile(tx, ty);
    }

    function setEntityToTile(entity, tx, ty) {
      entity.tileX = tx;
      entity.tileY = ty;
      const center = tileCenter(tx, ty);
      entity.x = center.x;
      entity.y = center.y;
      entity.targetX = center.x;
      entity.targetY = center.y;
    }

    function clampToWalkable(entity) {
      const tile = positionToTile(entity.x, entity.y);
      setEntityToTile(entity, tile.tx, tile.ty);
    }

    function pickRandomPortal() {
      if (portals.length === 0) {
        return { tx: 0, ty: Math.floor(mapRows.length / 2) };
      }
      return portals[Math.floor(Math.random() * portals.length)];
    }

    const enemyColors = [
      '#c44aff', // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
      '#ff44aa', // –†–æ–∑–æ–≤—ã–π
      '#44aaff', // –°–∏–Ω–∏–π
      '#ffaa44', // –û—Ä–∞–Ω–∂–µ–≤—ã–π
      '#aa44ff', // –ü—É—Ä–ø—É—Ä–Ω—ã–π
      '#44ffaa'  // –ë–∏—Ä—é–∑–æ–≤—ã–π
    ];

    function createEnemyAtTile(tx, ty, speed) {
      const portalX = tx * tileSize + halfTile;
      const portalY = ty * tileSize + halfTile;
      
      // –í—Ä–∞–≥ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –ø—Ä—è–º–æ –≤ –ø–æ—Ä—Ç–∞–ª–µ
      const enemy = {
        x: portalX,
        y: portalY,
        targetX: portalX,
        targetY: portalY,
        tileX: tx,
        tileY: ty,
        size: tileSize,
        speed: speed,
        color: enemyColors[Math.floor(Math.random() * enemyColors.length)]
      };
      
      // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Ä–∞–≥–∞ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é —Ç–∞–π–ª–∞
      setEntityToTile(enemy, tx, ty);
      
      return enemy;
    }

    function spawnEnemy() {
      const portal = pickRandomPortal();
      const baseSpeed = 1.2 + Math.random() * 0.6;
      const difficultyBoost = 1 + Math.min(score / 120, 0.7);
      const enemy = createEnemyAtTile(portal.tx, portal.ty, (baseSpeed * difficultyBoost));
      enemies.push(enemy);
    }

    let audioCtx = null;

    function ensureAudioContext() {
      if (audioCtx) {
        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        return audioCtx;
      }
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return null;
      audioCtx = new Ctx();
      return audioCtx;
    }

    function playSound(kind) {
      const ctx = ensureAudioContext();
      if (!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const now = ctx.currentTime;
      if (kind === 'shoot') {
        osc.frequency.value = 720;
        gain.gain.value = 0.08;
      } else {
        osc.frequency.value = 320;
        gain.gain.value = 0.12;
      }
      osc.type = 'triangle';
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      osc.stop(now + 0.2);
    }

    function playDeathSound() {
      const ctx = ensureAudioContext();
      if (!ctx) return;
      
      // –ó–≤—É–∫ —Å–º–µ—Ä—Ç–∏ - –Ω–∏—Å—Ö–æ–¥—è—â–∞—è –º–µ–ª–æ–¥–∏—è
      const notes = [
        { freq: 440, time: 0.0, duration: 0.2 },   // A4
        { freq: 392, time: 0.2, duration: 0.2 },    // G4
        { freq: 349, time: 0.4, duration: 0.3 },    // F4
        { freq: 294, time: 0.7, duration: 0.4 }     // D4
      ];

      notes.forEach(note => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const startTime = ctx.currentTime + note.time;
        
        osc.frequency.value = note.freq;
        osc.type = 'sawtooth';
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.032, startTime + 0.05);  // –£–º–µ–Ω—å—à–µ–Ω–æ –Ω–∞ 50% (0.064 * 0.5)
        gain.gain.linearRampToValueAtTime(0.016, startTime + note.duration - 0.1);  // –£–º–µ–Ω—å—à–µ–Ω–æ –Ω–∞ 50% (0.032 * 0.5)
        gain.gain.linearRampToValueAtTime(0, startTime + note.duration);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(startTime);
        osc.stop(startTime + note.duration);
      });
    }

    function playVictoryMusic() {
      const ctx = ensureAudioContext();
      if (!ctx) return;
      
      // –ü—Ä–∞–∑–¥–Ω–∏—á–Ω–∞—è –ø–æ–±–µ–¥–Ω–∞—è –º–µ–ª–æ–¥–∏—è - –º–∞–∂–æ—Ä–Ω–∞—è –≥–∞–º–º–∞ –≤–≤–µ—Ä—Ö
      const notes = [
        { freq: 523.25, time: 0.0, duration: 0.15 },   // C5
        { freq: 587.33, time: 0.15, duration: 0.15 },    // D5
        { freq: 659.25, time: 0.3, duration: 0.15 },    // E5
        { freq: 698.46, time: 0.45, duration: 0.15 },   // F5
        { freq: 783.99, time: 0.6, duration: 0.2 },     // G5
        { freq: 880.00, time: 0.8, duration: 0.2 },     // A5
        { freq: 987.77, time: 1.0, duration: 0.25 },    // B5
        { freq: 1046.50, time: 1.25, duration: 0.4 }    // C6 - —Ñ–∏–Ω–∞–ª—å–Ω–∞—è –Ω–æ—Ç–∞
      ];

      notes.forEach(note => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const startTime = ctx.currentTime + note.time;
        
        osc.frequency.value = note.freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.15, startTime + 0.02);
        gain.gain.linearRampToValueAtTime(0.1, startTime + note.duration - 0.05);
        gain.gain.linearRampToValueAtTime(0, startTime + note.duration);
        
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(startTime);
        osc.stop(startTime + note.duration);
      });

      // –î–æ–±–∞–≤–ª—è–µ–º –∞–∫–∫–æ—Ä–¥ –≤ –∫–æ–Ω—Ü–µ –¥–ª—è –ø—Ä–∞–∑–¥–Ω–∏—á–Ω–æ—Å—Ç–∏
      setTimeout(() => {
        const chordTime = ctx.currentTime + 1.7;
        [523.25, 659.25, 783.99].forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.frequency.value = freq;
          osc.type = 'sine';
          gain.gain.setValueAtTime(0, chordTime);
          gain.gain.linearRampToValueAtTime(0.12, chordTime + 0.05);
          gain.gain.linearRampToValueAtTime(0, chordTime + 0.5);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(chordTime);
          osc.stop(chordTime + 0.5);
        });
      }, 1700);
    }

    function shootArrow(force = false) {
      if ((!playing || paused) && !force) return;
      const magnitude = Math.hypot(player.dirX, player.dirY) || 1;
      const speed = 6;
      console.log('[CastleArrows Logs] Shooting arrow', {
        force,
        dir: { x: player.dirX, y: player.dirY },
        position: { x: player.x, y: player.y }
      });
      playSound('shoot');
      arrows.push({
        x: player.x,
        y: player.y,
        dx: (player.dirX / magnitude) * speed,
        dy: (player.dirY / magnitude) * speed,
        life: 90
      });
    }

    function isAtTarget(entity) {
      return Math.abs(entity.x - entity.targetX) < 0.1 && Math.abs(entity.y - entity.targetY) < 0.1;
    }

    function moveEntityTowardsTarget(entity) {
      if (isAtTarget(entity)) {
        entity.x = entity.targetX;
        entity.y = entity.targetY;
        return;
      }
      const dx = entity.targetX - entity.x;
      const stepX = Math.sign(dx) * Math.min(Math.abs(dx), entity.speed);
      entity.x += stepX;

      const dy = entity.targetY - entity.y;
      const stepY = Math.sign(dy) * Math.min(Math.abs(dy), entity.speed);
      entity.y += stepY;
    }

    function rotatePlayer(dx, dy) {
      if (dx === 0 && dy === 0) return;
      player.dirX = dx;
      player.dirY = dy;
    }

    function requestPlayerMove(dx, dy) {
      if (dx === 0 && dy === 0) return;
      const targetTileX = player.tileX + dx;
      const targetTileY = player.tileY + dy;
      if (!isWalkableTile(targetTileX, targetTileY)) return;
      player.tileX = targetTileX;
      player.tileY = targetTileY;
      const center = tileCenter(targetTileX, targetTileY);
      player.targetX = center.x;
      player.targetY = center.y;
      player.dirX = dx;
      player.dirY = dy;
    }

    function updatePlayer() {
      if (paused) return;
      if (isAtTarget(player)) {
        if (keys['ArrowUp'] || keys['KeyW']) {
          rotatePlayer(0, -1);
          requestPlayerMove(0, -1);
        } else if (keys['ArrowDown'] || keys['KeyS']) {
          rotatePlayer(0, 1);
          requestPlayerMove(0, 1);
        } else if (keys['ArrowLeft'] || keys['KeyA']) {
          rotatePlayer(-1, 0);
          requestPlayerMove(-1, 0);
        } else if (keys['ArrowRight'] || keys['KeyD']) {
          rotatePlayer(1, 0);
          requestPlayerMove(1, 0);
        }
      }
      moveEntityTowardsTarget(player);
    }

    function updateArrows() {
      arrows.forEach(a => {
        a.x += a.dx;
        a.y += a.dy;
        a.life--;
      });
      arrows = arrows.filter(a => a.life > 0 && a.x > -20 && a.x < canvas.width + 20 && a.y > -20 && a.y < canvas.height + 20);
    }

    function updateEnemies() {
      enemies.forEach(enemy => {
        // –í—Ä–∞–≥ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –ø—Ä—è–º–æ –≤ –ø–æ—Ä—Ç–∞–ª–µ –∏ —Å—Ä–∞–∑—É –¥–≤–∏–≥–∞–µ—Ç—Å—è –∫ –∏–≥—Ä–æ–∫—É
        if (isAtTarget(enemy)) {
          enemy.x = enemy.targetX;
          enemy.y = enemy.targetY;
          const dx = player.tileX - enemy.tileX;
          const dy = player.tileY - enemy.tileY;
          const preferX = Math.abs(dx) >= Math.abs(dy);
          const baseDirections = preferX
            ? [
                { dx: Math.sign(dx), dy: 0 },
                { dx: 0, dy: Math.sign(dy) },
                { dx: 0, dy: -Math.sign(dy) },
                { dx: -Math.sign(dx), dy: 0 }
              ]
            : [
                { dx: 0, dy: Math.sign(dy) },
                { dx: Math.sign(dx), dy: 0 },
                { dx: -Math.sign(dx), dy: 0 },
                { dx: 0, dy: -Math.sign(dy) }
              ];
          const directions = baseDirections.filter(dir => dir.dx !== 0 || dir.dy !== 0);
          if (directions.length === 0) {
            directions.push({ dx: 0, dy: 1 }, { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: -1, dy: 0 });
          }
          for (const dir of directions) {
            const nextTileX = enemy.tileX + dir.dx;
            const nextTileY = enemy.tileY + dir.dy;
            if (!isWalkableTile(nextTileX, nextTileY)) continue;
            enemy.tileX = nextTileX;
            enemy.tileY = nextTileY;
            const center = tileCenter(nextTileX, nextTileY);
            enemy.targetX = center.x;
            enemy.targetY = center.y;
            break;
          }
        }
        moveEntityTowardsTarget(enemy);
      });
    }

    function processArrowEnemyCollisions(activeArrows, activeEnemies) {
      let hits = 0;
      for (let ai = activeArrows.length - 1; ai >= 0; ai--) {
        const arrow = activeArrows[ai];
        let hitEnemyIndex = -1;
        for (let ei = activeEnemies.length - 1; ei >= 0; ei--) {
          const enemy = activeEnemies[ei];
          if (Math.hypot(arrow.x - enemy.x, arrow.y - enemy.y) < (enemy.size / 2 + 5)) {
            hitEnemyIndex = ei;
            break;
          }
        }
        if (hitEnemyIndex !== -1) {
          activeEnemies.splice(hitEnemyIndex, 1);
          activeArrows.splice(ai, 1);
          hits++;
        }
      }
      return hits;
    }

    function updateLives() {
      const hearts = '‚ô•'.repeat(lives) + '‚ô°'.repeat(Math.max(0, 3 - lives));
      livesDisplay.textContent = '–ñ–∏–∑–Ω–∏: ' + hearts;
    }

    function handleCollisions() {
      // Arrow hits enemy
      const beforeEnemies = enemies.length;
      const beforeArrows = arrows.length;
      const hits = processArrowEnemyCollisions(arrows, enemies);
      if (hits > 0 || enemies.length !== beforeEnemies || arrows.length !== beforeArrows) {
        console.log('[CastleArrows Logs] Collision result', {
          hits,
          enemiesBefore: beforeEnemies,
          enemiesAfter: enemies.length,
          arrowsBefore: beforeArrows,
          arrowsAfter: arrows.length
        });
      }
      if (hits > 0) {
        score += hits * 5;
        killsInLevel += hits;
        updateLevelDisplay();
        playSound('hit');
        
        if (killsInLevel >= KILLS_NEEDED_PER_LEVEL) {
          nextLevel();
        }
      }

      // Enemy hits player
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (Math.hypot(enemy.x - player.x, enemy.y - player.y) < (enemy.size / 2 + player.size / 2 - 4)) {
          enemies.splice(i, 1);
          lives--;
          updateLives();
          
          // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Å–º–µ—Ä—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
          if (!playerDeathAnimation) {
            playerDeathAnimation = {
              x: player.x,
              y: player.y,
              size: player.size,
              progress: 0,
              maxProgress: 60 // 1 —Å–µ–∫—É–Ω–¥–∞ –ø—Ä–∏ 60 FPS
            };
            playDeathSound();
          }
          
          if (lives <= 0) {
            playing = false;
            paused = false;
            pauseBtn.style.display = 'none';
            startBtn.style.display = 'block';
            gameOverText.textContent = '–û –Ω–µ—Ç! –í—Ä–∞–≥ —Ç–µ–±—è –¥–æ–≥–Ω–∞–ª. –ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç¬ª.';
          } else {
            gameOverText.textContent = '–ê–π! –û—Å—Ç–∞–ª–æ—Å—å –∂–∏–∑–Ω–µ–π: ' + lives;
            setTimeout(() => {
              if (gameOverText.textContent.includes('–ê–π!')) {
                gameOverText.textContent = '';
              }
            }, 2000);
          }
        }
      }
    }

    function drawPlayer() {
      // –ï—Å–ª–∏ –µ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏—è —Å–º–µ—Ä—Ç–∏, —Ä–∏—Å—É–µ–º –µ—ë
      if (playerDeathAnimation) {
        ctx.save();
        ctx.translate(playerDeathAnimation.x, playerDeathAnimation.y);
        const progress = playerDeathAnimation.progress / playerDeathAnimation.maxProgress;
        const alpha = 1 - progress;
        const scale = 1 + progress * 2; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø—Ä–∏ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–∏
        const rotation = progress * Math.PI * 4; // –í—Ä–∞—â–µ–Ω–∏–µ
        
        ctx.globalAlpha = alpha;
        ctx.scale(scale, scale);
        ctx.rotate(rotation);
        
        // –†–∏—Å—É–µ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
        ctx.fillStyle = '#ff4444'; // –ö—Ä–∞—Å–Ω—ã–π —Ü–≤–µ—Ç –ø—Ä–∏ —Å–º–µ—Ä—Ç–∏
        ctx.beginPath();
        ctx.arc(0, 0, playerDeathAnimation.size / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // –ß–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 / 8) * i + rotation;
          const distance = progress * 30;
          ctx.fillStyle = `rgba(255, ${100 + i * 20}, ${50 + i * 10}, ${alpha})`;
          ctx.beginPath();
          ctx.arc(
            Math.cos(angle) * distance,
            Math.sin(angle) * distance,
            3,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        
        ctx.restore();
        return;
      }
      
      // –û–±—ã—á–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.fillStyle = '#5bd1ff';
      ctx.beginPath();
      ctx.arc(0, 0, player.size / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(player.dirX * 18, player.dirY * 18);
      ctx.stroke();
      ctx.restore();
    }

    function drawArrows() {
      ctx.fillStyle = '#ffd35b';
      arrows.forEach(a => {
        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.rotate(Math.atan2(a.dy, a.dx));
        ctx.fillRect(-8, -2, 16, 4);
        ctx.restore();
      });
    }

    function drawEnemies() {
      enemies.forEach(e => {
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ffffff44';
        ctx.stroke();
      });
    }

    function drawMap() {
      for (let y = 0; y < mapRows.length; y++) {
        for (let x = 0; x < mapRows[y].length; x++) {
          const tile = mapRows[y].charAt(x);
          const px = x * tileSize;
          const py = y * tileSize;
          if (tile === '1') {
            ctx.fillStyle = '#130a1f';
            ctx.fillRect(px, py, tileSize, tileSize);
            ctx.strokeStyle = '#231533';
            ctx.strokeRect(px, py, tileSize, tileSize);
          } else {
            ctx.fillStyle = '#271a38';
            ctx.fillRect(px, py, tileSize, tileSize);
            ctx.strokeStyle = '#38234c';
            ctx.strokeRect(px, py, tileSize, tileSize);
          }
        }
      }
    }

    function drawPortals() {
      portals.forEach(portal => {
        portal.animationPhase = (portal.animationPhase || 0) + 0.1;
        const pulse = Math.sin(portal.animationPhase) * 0.3 + 0.7;
        
        // –í–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ –ø–æ—Ä—Ç–∞–ª–∞
        const gradient = ctx.createRadialGradient(
          portal.x, portal.y, 0,
          portal.x, portal.y, tileSize
        );
        gradient.addColorStop(0, `rgba(196, 74, 255, ${0.6 * pulse})`);
        gradient.addColorStop(0.5, `rgba(196, 74, 255, ${0.3 * pulse})`);
        gradient.addColorStop(1, 'rgba(196, 74, 255, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(portal.x, portal.y, tileSize * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥ –ø–æ—Ä—Ç–∞–ª–∞
        ctx.fillStyle = `rgba(196, 74, 255, ${0.4 * pulse})`;
        ctx.beginPath();
        ctx.arc(portal.x, portal.y, tileSize * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
        ctx.beginPath();
        ctx.arc(portal.x, portal.y, tileSize * 0.15, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function runCollisionTests() {
      const arrowsHit = [{ x: 50, y: 50, dx: 0, dy: 0, life: 1 }];
      const enemiesHit = [{ x: 50, y: 50, size: 26 }];
      const hitResult = processArrowEnemyCollisions(arrowsHit, enemiesHit) === 1 &&
        arrowsHit.length === 0 && enemiesHit.length === 0;

      const arrowsMiss = [{ x: 0, y: 0, dx: 0, dy: 0, life: 1 }];
      const enemiesMiss = [{ x: 200, y: 200, size: 26 }, { x: 300, y: 300, size: 26 }];
      const missResult = processArrowEnemyCollisions(arrowsMiss, enemiesMiss) === 0 &&
        enemiesMiss.length === 2 && arrowsMiss.length === 1;

      const passed = hitResult && missResult;
      console.log('[CastleArrows Tests] Arrow removes only collided enemy:', hitResult ? 'OK' : 'FAIL');
      console.log('[CastleArrows Tests] No removal when miss:', missResult ? 'OK' : 'FAIL');
      return passed;
    }

    function runPortalTests() {
      let allPassed = true;
      
      // –¢–µ—Å—Ç 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –ø–æ—Ä—Ç–∞–ª–æ–≤ –≤—Å–µ–≥–¥–∞ 3 –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ
      for (let level = 1; level <= MAX_LEVEL; level++) {
        updateMapForLevel(level);
        const portalCount = portals.length;
        const passed = portalCount === 3;
        allPassed = allPassed && passed;
        console.log(`[Portal Tests] Level ${level} has exactly 3 portals:`, passed ? 'OK' : `FAIL (found ${portalCount})`);
      }
      
      // –¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –≤—Å–µ –ø–æ—Ä—Ç–∞–ª—ã –Ω–∞ –ø—Ä–æ—Ö–æ–¥–∏–º—ã—Ö —Ç–∞–π–ª–∞—Ö
      for (let level = 1; level <= MAX_LEVEL; level++) {
        updateMapForLevel(level);
        let allWalkable = true;
        portals.forEach(portal => {
          if (!isWalkableTile(portal.tx, portal.ty)) {
            allWalkable = false;
          }
        });
        allPassed = allPassed && allWalkable;
        console.log(`[Portal Tests] Level ${level} portals are on walkable tiles:`, allWalkable ? 'OK' : 'FAIL');
      }
      
      // –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ 2 –ø–æ—Ä—Ç–∞–ª–∞ —Å–ª–µ–≤–∞ (tx = 0) –∏ 1 —Å–ø—Ä–∞–≤–∞ (tx = maxX)
      for (let level = 1; level <= MAX_LEVEL; level++) {
        updateMapForLevel(level);
        const maxX = mapRows[0].length - 1;
        const leftPortals = portals.filter(p => p.tx === 0);
        const rightPortals = portals.filter(p => p.tx === maxX);
        const passed = leftPortals.length === 2 && rightPortals.length === 1;
        allPassed = allPassed && passed;
        console.log(`[Portal Tests] Level ${level} has 2 left portals and 1 right portal:`, passed ? 'OK' : `FAIL (left: ${leftPortals.length}, right: ${rightPortals.length})`);
      }
      
      // –¢–µ—Å—Ç 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –≤—Ä–∞–≥–∏ —Ä–∞–∑–Ω–æ—Ü–≤–µ—Ç–Ω—ã–µ
      const testEnemy1 = createEnemyAtTile(0, 1, 1.0);
      const testEnemy2 = createEnemyAtTile(0, 2, 1.0);
      const testEnemy3 = createEnemyAtTile(0, 3, 1.0);
      const colors = [testEnemy1.color, testEnemy2.color, testEnemy3.color];
      const uniqueColors = new Set(colors);
      const hasVariety = uniqueColors.size >= 2 || colors.length >= 3; // –•–æ—Ç—è –±—ã 2 —Ä–∞–∑–Ω—ã—Ö —Ü–≤–µ—Ç–∞ –ø—Ä–∏ 3 –≤—Ä–∞–≥–∞—Ö
      allPassed = allPassed && hasVariety;
      console.log('[Portal Tests] Enemies have different colors:', hasVariety ? 'OK' : 'FAIL');
      
      // –¢–µ—Å—Ç 5: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –≤—Ä–∞–≥–∏ –Ω–µ –ø–æ—è–≤–ª—è—é—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ —Å—Ç–µ–Ω
      for (let level = 1; level <= MAX_LEVEL; level++) {
        updateMapForLevel(level);
        let allValid = true;
        for (let i = 0; i < 10; i++) {
          const portal = pickRandomPortal();
          if (!isWalkableTile(portal.tx, portal.ty)) {
            allValid = false;
            break;
          }
        }
        allPassed = allPassed && allValid;
        console.log(`[Portal Tests] Level ${level} enemies spawn from walkable portals:`, allValid ? 'OK' : 'FAIL');
      }
      
      // –¢–µ—Å—Ç 6: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –≤—Ä–∞–≥–∏ –ø–æ—è–≤–ª—è—é—Ç—Å—è –ø—Ä—è–º–æ –≤ –ø–æ—Ä—Ç–∞–ª–µ
      const maxX = mapRows[0].length - 1;
      const testEnemyLeft = createEnemyAtTile(0, 1, 1.0);
      const testEnemyRight = createEnemyAtTile(maxX, 1, 1.0);
      const leftPortalX = 0 * tileSize + halfTile;
      const rightPortalX = maxX * tileSize + halfTile;
      const leftInPortal = Math.abs(testEnemyLeft.x - leftPortalX) < 1 && Math.abs(testEnemyLeft.y - (1 * tileSize + halfTile)) < 1;
      const rightInPortal = Math.abs(testEnemyRight.x - rightPortalX) < 1 && Math.abs(testEnemyRight.y - (1 * tileSize + halfTile)) < 1;
      const spawnsInPortal = leftInPortal && rightInPortal;
      allPassed = allPassed && spawnsInPortal;
      console.log('[Portal Tests] Enemies spawn directly in portal:', spawnsInPortal ? 'OK' : 'FAIL');
      
      return allPassed;
    }

    let spacePressed = false;

    document.addEventListener('keydown', (e) => {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–∞—É–∑—ã –ø–æ –∫–ª–∞–≤–∏—à–∞–º P –∏–ª–∏ Escape
      if ((e.code === 'KeyP' || e.code === 'Escape') && playing) {
        paused = !paused;
        if (paused) {
          pauseBtn.textContent = '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
        } else {
          pauseBtn.textContent = '–ü–∞—É–∑–∞';
          if (!animationId && playing) {
            animationId = requestAnimationFrame(gameLoop);
          }
        }
        e.preventDefault();
        return;
      }
      
      if (e.code === 'Space' && !spacePressed && !paused) {
        shootArrow();
        spacePressed = true;
      }
      keys[e.code] = true;
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        spacePressed = false;
      }
      keys[e.code] = false;
    });

    function gameLoop() {
      if (!playing && !playerDeathAnimation && !levelTransitionActive) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      drawPortals();
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Å–º–µ—Ä—Ç–∏
      if (playerDeathAnimation) {
        playerDeathAnimation.progress++;
        if (playerDeathAnimation.progress >= playerDeathAnimation.maxProgress) {
          playerDeathAnimation = null;
          // –ï—Å–ª–∏ –∂–∏–∑–Ω–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å, –∏–≥—Ä–∞ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è
          if (lives <= 0) {
            playing = false;
          }
        }
      }
      
      if (playing && !paused && !levelTransitionActive) {
        // –ò–≥—Ä–æ–∫ –Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Å–º–µ—Ä—Ç–∏
        if (!playerDeathAnimation) {
          updatePlayer();
        }
        // –°—Ç—Ä–µ–ª—ã –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç –ª–µ—Ç–µ—Ç—å
        updateArrows();
        // –í—Ä–∞–≥–∏ –Ω–µ –¥–≤–∏–≥–∞—é—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ—Ç–µ—Ä–∏ –∂–∏–∑–Ω–∏
        if (!playerDeathAnimation) {
          updateEnemies();
        }
        // –ö–æ–ª–ª–∏–∑–∏–∏ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Å–º–µ—Ä—Ç–∏
        if (!playerDeathAnimation) {
          handleCollisions();
        }
      }
      
      drawEnemies();
      drawArrows();
      drawPlayer();
      
      // –†–∏—Å—É–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–∞—É–∑—ã
      if (paused && playing) {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#dfbf6c';
        ctx.font = 'bold 48px "Trebuchet MS", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('–ü–ê–£–ó–ê', canvas.width / 2, canvas.height / 2);
        ctx.restore();
      }

      if (playing && !levelTransitionActive && !paused) {
        spawnTimer++;
        const spawnInterval = Math.max(60, 120 - (currentLevel - 1) * 20);
        if (spawnTimer > spawnInterval) {
          spawnEnemy();
          spawnTimer = 0;
        }
      }

      if (playing || playerDeathAnimation || levelTransitionActive) {
        animationId = requestAnimationFrame(gameLoop);
      } else {
        animationId = null;
      }
    }

    startBtn.addEventListener('click', () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      ensureAudioContext();
      resetGame();
      playing = true;
      paused = false;
      pauseBtn.style.display = 'block';
      startBtn.style.display = 'none';
      spawnEnemy();
      spawnEnemy();
      animationId = requestAnimationFrame(gameLoop);
    });
    
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      if (paused) {
        pauseBtn.textContent = '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
      } else {
        pauseBtn.textContent = '–ü–∞—É–∑–∞';
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª, –µ—Å–ª–∏ –æ–Ω –æ—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è
        if (!animationId && playing) {
          animationId = requestAnimationFrame(gameLoop);
        }
      }
    });

    const debugAPI = {
      resetGame: () => resetGame(),
      shootArrow: (force = false) => shootArrow(force),
      handleCollisions: () => handleCollisions(),
      addEnemy: (enemy = {}) => {
        const tile = enemy.tx !== undefined && enemy.ty !== undefined
          ? { tx: enemy.tx, ty: enemy.ty }
          : positionToTile(enemy.x ?? canvas.width / 2, enemy.y ?? canvas.height / 2);
        const newEnemy = createEnemyAtTile(tile.tx, tile.ty, enemy.speed ?? 1.2);
        newEnemy.color = enemy.color ?? '#c44aff';
        enemies.push(newEnemy);
      },
      clearArrows: () => { arrows = []; },
      setPlaying: (value) => { playing = value; },
      setPlayerPosition: (x, y) => {
        const tile = positionToTile(
          typeof x === 'number' ? x : player.x,
          typeof y === 'number' ? y : player.y
        );
        setEntityToTile(player, tile.tx, tile.ty);
      },
      getState: () => ({
        player: { ...player },
        arrows: arrows.map(a => ({ ...a })),
        enemies: enemies.map(e => ({ ...e })),
        score,
        lives
      })
    };

    window.__castleGameDebug = debugAPI;

    function runMapVisualizationTests() {
      console.log('\n=== –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–†–¢ ===\n');
      
      for (let level = 1; level <= MAX_LEVEL; level++) {
        const map = levelMaps[level - 1];
        const approach = mapApproaches[level - 1] || '';
        
        console.log(`\n--- –£—Ä–æ–≤–µ–Ω—å ${level}: ${approach} ---`);
        console.log(`–†–∞–∑–º–µ—Ä: ${map[0].length} x ${map.length}`);
        
        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã
        console.log('\n–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã (1=—Å—Ç–µ–Ω–∞, 0=–∫–æ—Ä–∏–¥–æ—Ä):');
        console.log('‚îå' + '‚îÄ'.repeat(map[0].length) + '‚îê');
        map.forEach((row, y) => {
          let visualRow = '‚îÇ';
          for (let x = 0; x < row.length; x++) {
            const tile = row.charAt(x);
            if (tile === '1') {
              visualRow += '‚ñà';  // –°—Ç–µ–Ω–∞
            } else {
              visualRow += ' ';  // –ö–æ—Ä–∏–¥–æ—Ä
            }
          }
          visualRow += '‚îÇ';
          console.log(visualRow);
        });
        console.log('‚îî' + '‚îÄ'.repeat(map[0].length) + '‚îò');
        
        // –ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        let wallRows = 0;
        let corridorRows = 0;
        let mixedRows = 0;
        
        map.forEach(row => {
          const hasWalls = row.includes('1');
          const hasCorridors = row.includes('0');
          if (hasWalls && hasCorridors) {
            mixedRows++;
          } else if (hasWalls) {
            wallRows++;
          } else {
            corridorRows++;
          }
        });
        
        console.log(`\n–ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:`);
        console.log(`  - –°—Ç—Ä–æ–∫–∏ —Å–æ —Å—Ç–µ–Ω–∞–º–∏: ${wallRows}`);
        console.log(`  - –°—Ç—Ä–æ–∫–∏ —Å –∫–æ—Ä–∏–¥–æ—Ä–∞–º–∏: ${corridorRows}`);
        console.log(`  - –°–º–µ—à–∞–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏: ${mixedRows}`);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–º–º–µ—Ç—Ä–∏–∏
        let symmetric = true;
        for (let y = 0; y < map.length; y++) {
          const row = map[y];
          const reversed = row.split('').reverse().join('');
          if (row !== reversed) {
            symmetric = false;
            break;
          }
        }
        console.log(`  - –°–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞—è: ${symmetric ? '–î–ê' : '–ù–ï–¢'}`);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä
        const innerRows = map.slice(1, map.length - 1); // –ë–µ–∑ –≥—Ä–∞–Ω–∏—Ü
        const uniqueRows = new Set(innerRows);
        console.log(`  - –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Å—Ç—Ä–æ–∫: ${uniqueRows.size} –∏–∑ ${innerRows.length}`);
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –±–∞—à–µ–Ω/–≤—ã—Å—Ç—É–ø–æ–≤
        const topRow = map[2]; // –¢—Ä–µ—Ç—å—è —Å—Ç—Ä–æ–∫–∞ (–ø–æ—Å–ª–µ –≥—Ä–∞–Ω–∏—Ü—ã –∏ –ø—É—Å—Ç–æ–π)
        const bottomRow = map[map.length - 3]; // –ü—Ä–µ–¥–ø–æ—Å–ª–µ–¥–Ω—è—è —Å—Ç—Ä–æ–∫–∞ –ø–µ—Ä–µ–¥ –≥—Ä–∞–Ω–∏—Ü–µ–π
        const hasLeftTower = topRow && topRow.startsWith('00111101');
        const hasRightTower = bottomRow && bottomRow.endsWith('011111110');
        console.log(`  - –ë–∞—à–Ω—è —Å–ª–µ–≤–∞ –≤–≤–µ—Ä—Ö—É: ${hasLeftTower ? '–î–ê' : '–ù–ï–¢'}`);
        console.log(`  - –ë–∞—à–Ω—è —Å–ø—Ä–∞–≤–∞ –≤–Ω–∏–∑—É: ${hasRightTower ? '–î–ê' : '–ù–ï–¢'}`);
      }
      
      console.log('\n=== –ö–û–ù–ï–¶ –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò ===\n');
      return true;
    }

    window.runCollisionTests = runCollisionTests;
    window.runPortalTests = runPortalTests;
    window.runMapVisualizationTests = runMapVisualizationTests;
    runCollisionTests();
    runPortalTests();
    runMapVisualizationTests();
  </script>
</body>
</html>
